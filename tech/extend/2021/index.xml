<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>记事本 – 2021</title>
    <link>/tech/extend/2021/</link>
    <description>Recent content in 2021 on 记事本</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 08 Nov 2021 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/tech/extend/2021/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Tech: docker运行qbittorrent</title>
      <link>/web/note/2021/2021110801.html</link>
      <pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/web/note/2021/2021110801.html</guid>
      <description>
        
        
        &lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;
&lt;p&gt;之所以使用docker运行qbittorrent是为了针对型的配置qbittorrent，修改默认下载位置，使用端口号等操作。&lt;/p&gt;
&lt;h3 id=&#34;第一步-准备服务器&#34;&gt;第一步 准备服务器&lt;/h3&gt;
&lt;h4 id=&#34;登录云服务器&#34;&gt;登录云服务器&lt;/h4&gt;
&lt;p&gt;通过ssh命令使用购买服务器后提供的用户名和密码登录服务器，如果你是使用的Hetzner服务器需要自行配置RAID0，##先不要急着登录服务器##&lt;/p&gt;
&lt;h4 id=&#34;配置raid&#34;&gt;配置RAID&lt;/h4&gt;
&lt;p&gt;第一步 进入Hetzner的控制后台，找到服务器，选择Rescue (救援模式)，设置完成后重启服务器&lt;/p&gt;
&lt;p&gt;第二步 登陆云服务器，进入救援模式，使用&lt;code&gt;installimage&lt;/code&gt;配置服务器初始化&lt;/p&gt;
&lt;p&gt;其他使用默认配置，只需要根据下图，修改服务器的RAID 为&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://base.oribos.city/images/2021/11/1554730489.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;RAID设置区分
NO RIAD：一般情况建议不设置RAID，这样既保证空间大小，也保证了安全性.；
RIAD 0：好处：速度快，合并容量，缺点：两个硬盘只要挂一个，那么文件全都挂了；
RIAD 1：好处：同时把文件写入到两个硬盘，坏一个也没事，缺点：浪费空间，读写速度稍微有降低；&lt;/p&gt;
&lt;p&gt;编辑完成后按F10 保存配置文件；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt; 登录救援模式后本地会保存服务器的验证信息，重新登录服务器需要先删除之前的验证信息，避免出现验证信息修改的报错。&lt;/p&gt;
&lt;h4 id=&#34;配置磁盘空间&#34;&gt;配置磁盘空间&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;fdisk -l&lt;/code&gt;查看服务器的硬盘，将未挂载的硬盘挂载的目录，对于配置永久挂载的请参考其他文章编辑磁盘配置文件。这里的挂载只是临时性的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount /dev/md3 /denalon/downloads&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;挂载&lt;code&gt;/dev/md3&lt;/code&gt;的硬盘空间为目录&lt;code&gt;/denalon/downloads&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;第二步-准备docker环境&#34;&gt;第二步 准备docker环境&lt;/h3&gt;
&lt;h4 id=&#34;一键安装docker&#34;&gt;一键安装docker&lt;/h4&gt;
&lt;p&gt;对于大多数服务器使用一键安装脚本即可安装docker&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果安装时报错，意味着服务器上某些应用未正确安装和配置，可以参考自定义安装docker&lt;/p&gt;
&lt;h4 id=&#34;自定义安装docker&#34;&gt;自定义安装docker&lt;/h4&gt;
&lt;p&gt;为没有安装sudo的机器安装&lt;code&gt;sudo&lt;/code&gt;，避免抄一下代码运行时报错&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apt-get install sudo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;卸载旧版docker&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get remove docker docker-engine docker.io containerd runc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新包&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装必要组件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; sudo apt-get update
 sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置官方 GPG 密钥&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; echo \
  &amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \
  $(lsb_release -cs) stable&amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装docker&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;安装docker-compose&#34;&gt;安装docker-compose&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo curl -L &amp;#34;https://github.com/docker/compose/releases/download/v2.0.1/docker-compose-$(uname -s)-$(uname -m)&amp;#34; -o /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;第三步-部署qbittorrent&#34;&gt;第三步 部署qbittorrent&lt;/h3&gt;
&lt;h4 id=&#34;qbittorrent的配置文件&#34;&gt;qbittorrent的配置文件&lt;/h4&gt;
&lt;p&gt;docker-compose.yml内容&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;version: &amp;#34;3.9&amp;#34;
services:
  qbittorrent:
    image: linuxserver/qbittorrent
    container_name: qbittorrent
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/London
      - WEBUI_PORT=8080
    volumes:
      - ./config:/config
      - ./downloads:/downloads
    ports:
      - 6881:6881
      - 6881:6881/udp
      - 17010:17010
      - 17010:17010/udp
      - 8080:8080
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;运行docker-compose-up--d&#34;&gt;运行docker-compose up -d&lt;/h4&gt;
&lt;p&gt;直接在目录下运行docker-compose up -d即可&lt;/p&gt;
&lt;h4 id=&#34;登录qbittorrent&#34;&gt;登录qbittorrent&lt;/h4&gt;
&lt;p&gt;用户名 admin&lt;/p&gt;
&lt;p&gt;密码 adminadmin&lt;/p&gt;
&lt;h4 id=&#34;配置qbittorrent参数&#34;&gt;配置qbittorrent参数&lt;/h4&gt;
&lt;p&gt;根据需要修改下载和上传的连接数和流量控制，中文界面，登录端口号和密码&lt;/p&gt;
&lt;h3 id=&#34;第四步-优化&#34;&gt;第四步 优化&lt;/h3&gt;
&lt;h3 id=&#34;其他-安装quickbox&#34;&gt;其他 安装quickbox&lt;/h3&gt;
&lt;p&gt;1安装Ubuntu     &lt;a href=&#34;https://cn.wiki.ptbox.dev/hetzner-onekey/&#34;&gt;https://cn.wiki.ptbox.dev/hetzner-onekey/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;echo x | installimage -p /boot:ext3:1G,/:ext4:all -l 0 -r yes -i images/Ubuntu-1804-bionic-64-minimal.tar.gz -a -n Hz &amp;amp;&amp;amp; reboot&lt;/p&gt;
&lt;p&gt;2你需要首先以 root 身份登录，运行以下指令来抓取最新的代码 … &lt;a href=&#34;https://www.qiuvps.com/1382.html&#34;&gt;https://www.qiuvps.com/1382.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;apt-get -yqq update
apt-get -yqq upgrade
apt-get -yqq install git lsb-release dos2unix
git clone &lt;a href=&#34;https://github.com/amefs/quickbox-lite.git&#34;&gt;https://github.com/amefs/quickbox-lite.git&lt;/a&gt; /etc/QuickBox
dos2unix /etc/QuickBox/setup.sh
bash /etc/QuickBox/setup.sh&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Tech: 随笔2021-11-04</title>
      <link>/web/note/2021/2021110401.html</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/web/note/2021/2021110401.html</guid>
      <description>
        
        
        &lt;h3 id=&#34;hexo糟糕的使用&#34;&gt;hexo糟糕的使用&lt;/h3&gt;
&lt;p&gt;我部署了一个hexo&lt;a href=&#34;https://frednab.coding.net/public/dev/hexo-blog/git/files&#34;&gt;主题模板&lt;/a&gt; ，当今天无意间想增加一些有趣的主题时发现许多问题。一些主题使用了五花八门的依赖，这些依赖要么对hexo版本有要求要么对nodejs环境有要求，导致在本机运行hexo init 以后生成的项目，部署新主题时，要么依赖低，要么依赖高，要么组件下载404错误。&lt;/p&gt;
&lt;p&gt;一些主题并没有按照hexo官方指导的方式，使用_config.主题名.yml和_config.yml分开的方法，而是采用npm安装，然后将主题移动到themes目录下的奇葩操作。有些则是在hexo init生成的环境安装其主题后显示&lt;code&gt;  err: TypeError: Cannot read property &#39;path&#39; of undefined&lt;/code&gt;等各类错误。&lt;/p&gt;
&lt;p&gt;总之，hexo的各类乱七八糟的主题要求参差不齐，组件五花八门，有些甚至需要更改nodejs环境，代理连接等等操作导致部署失败率太高。&lt;/p&gt;
&lt;h3 id=&#34;hexo报错机制&#34;&gt;hexo报错机制&lt;/h3&gt;
&lt;p&gt;hexo使用nodejs环境，npm包管理器，各类涉及依赖和组件的版本要求五花八门，而报错信息几乎一点用都没有。&lt;/p&gt;
&lt;p&gt;如下图铺天盖地的报错和提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://base.oribos.city/images/2021/11/110401.png&#34; alt=&#34;提示1&#34;&gt;
&lt;img src=&#34;https://base.oribos.city/images/2021/11/110402.png&#34; alt=&#34;提示2&#34;&gt;
&lt;img src=&#34;https://base.oribos.city/images/2021/11/110403.png&#34; alt=&#34;提示3&#34;&gt;
&lt;img src=&#34;https://base.oribos.city/images/2021/11/110404.png&#34; alt=&#34;提示4&#34;&gt;&lt;/p&gt;
&lt;p&gt;不知道的还以为拿hexo做什么复杂的高科技研发工作&lt;/p&gt;
&lt;h3 id=&#34;hetzner奇葩的登录方式&#34;&gt;Hetzner奇葩的登录方式&lt;/h3&gt;
&lt;p&gt;在使用Hetzner云服务时发现一个奇葩的现象：登录服务需要使用一个“Client number”的客户码&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://base.oribos.city/images/2021/11/110405.png&#34; alt=&#34;hetzner登录界面&#34;&gt;&lt;/p&gt;
&lt;p&gt;问题时这个客户码不是用户自定义有意义的号码或者id，而是hetzner随机生成的，这个客户码可以在&lt;strong&gt;登录以后找到&lt;/strong&gt;，也就是说用户第一次注册时必须牢记这个客户码，以后续登录。如果忘记或者压根就不知道自己有什么客户码，那不好意思，无法登录。而且hetzner并没有通过用户注册时的邮箱或其他用户id的方式快捷的找回客户码，也没有使用用户id，邮箱地址来登录的备用方式。&lt;/p&gt;
&lt;p&gt;着实是商家狠狠的教用户怎么用产品&lt;/p&gt;
&lt;h3 id=&#34;改变的成本&#34;&gt;改变的成本&lt;/h3&gt;

      </description>
    </item>
    
    <item>
      <title>Tech: 分享</title>
      <link>/web/note/2021/2021071001/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/web/note/2021/2021071001/</guid>
      <description>
        
        
        &lt;h3 id=&#34;hexo&#34;&gt;hexo&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://frednab.coding.net/public/dev/hexo-blog/git/files&#34;&gt;普通部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://frednab.coding.net/public/dev/hexo-pre-install/git/files&#34;&gt;使用npm部署&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;docker&#34;&gt;docker&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://denalon.coding.net/public/asset/docker-app/git/files&#34;&gt;docker模板&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://frednab.coding.net/public/build/docker-build/git/files&#34;&gt;一些docker项目代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;树莓派更新软件源&#34;&gt;树莓派更新软件源&lt;/h3&gt;
&lt;p&gt;1、当前树莓派4b基于debian10&lt;/p&gt;
&lt;p&gt;一、国内源说明
1、先到https://tvtv.fun/ping测一下速度，看看哪个比较快，这里以电子科技大学为例&lt;/p&gt;
&lt;p&gt;2、需要改的源有两个：Raspbian 和 Raspberrypi。可以看镜像站的使用说明如科技大学说明&lt;/p&gt;
&lt;p&gt;二、改&lt;/p&gt;
&lt;p&gt;1.系统源
备份原文件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一键修改&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo sed -i &amp;#39;s|raspbian.raspberrypi.org|mirrors.ustc.edu.cn/raspbian|g&amp;#39; /etc/apt/sources.list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以用nano手动把raspbian.raspberrypi.org/替换成mirrors.ustc.edu.cn/raspbian/&lt;/p&gt;
&lt;p&gt;2.软件源
备份原文件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一键修改&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo sed -i &amp;#39;s|//archive.raspberrypi.org|//mirrors.ustc.edu.cn/archive.raspberrypi.org|g&amp;#39; /etc/apt/sources.list.d/raspi.list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.更新索引（修改源后必做）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.更新软件包（建议）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get upgrade 
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Tech: 博客内容更新包</title>
      <link>/web/note/2021/2021010117.html</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/web/note/2021/2021010117.html</guid>
      <description>
        
        
        &lt;h3 id=&#34;博客内容更新包&#34;&gt;博客内容更新包&lt;/h3&gt;
&lt;p&gt;该仓库是作为脱离于博客存档文章以外的额外更新包。平时针对该仓库进行管理和更新，当年末时，这些文章将转移到存档目录下，文章的url地址不变&lt;/p&gt;
&lt;h3 id=&#34;cloudflare-内容代理&#34;&gt;cloudflare 内容代理&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;#39;use strict&amp;#39;

/**
 * static files (404.html, sw.js, conf.js)
 */
const ASSET_URL = &amp;#39;http://fly.oribos.cn&amp;#39;

const JS_VER = 10
const MAX_RETRY = 1

/** @type {RequestInit} */
const PREFLIGHT_INIT = {
  status: 204,
  headers: new Headers({
    &amp;#39;access-control-allow-origin&amp;#39;: &amp;#39;*&amp;#39;,
    &amp;#39;access-control-allow-methods&amp;#39;: &amp;#39;GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS&amp;#39;,
    &amp;#39;access-control-max-age&amp;#39;: &amp;#39;1728000&amp;#39;,
  }),
}

/**
 * @param {any} body
 * @param {number} status
 * @param {Object&amp;lt;string, string&amp;gt;} headers
 */
function makeRes(body, status = 200, headers = {}) {
  headers[&amp;#39;--ver&amp;#39;] = JS_VER
  headers[&amp;#39;access-control-allow-origin&amp;#39;] = &amp;#39;*&amp;#39;
  return new Response(body, {status, headers})
}


/**
 * @param {string} urlStr 
 */
function newUrl(urlStr) {
  try {
    return new URL(urlStr)
  } catch (err) {
    return null
  }
}


addEventListener(&amp;#39;fetch&amp;#39;, e =&amp;gt; {
  const ret = fetchHandler(e)
    .catch(err =&amp;gt; makeRes(&amp;#39;cfworker error:\n&amp;#39; + err.stack, 502))
  e.respondWith(ret)
})


/**
 * @param {FetchEvent} e 
 */
async function fetchHandler(e) {
  const req = e.request
  const urlStr = req.url
  const urlObj = new URL(urlStr)
  const path = urlObj.href.substr(urlObj.origin.length)

  if (urlObj.protocol === &amp;#39;http:&amp;#39;) {
    urlObj.protocol = &amp;#39;https:&amp;#39;
    return makeRes(&amp;#39;&amp;#39;, 301, {
      &amp;#39;strict-transport-security&amp;#39;: &amp;#39;max-age=99999999; includeSubDomains; preload&amp;#39;,
      &amp;#39;location&amp;#39;: urlObj.href,
    })
  }

  if (path.startsWith(&amp;#39;/http/&amp;#39;)) {
    return httpHandler(req, path.substr(6))
  }

  switch (path) {
  case &amp;#39;/http&amp;#39;:
    return makeRes(&amp;#39;请更新 cfworker 到最新版本!&amp;#39;)
  case &amp;#39;/ws&amp;#39;:
    return makeRes(&amp;#39;not support&amp;#39;, 400)
  case &amp;#39;/works&amp;#39;:
    return makeRes(&amp;#39;it works&amp;#39;)
  default:
    // static files
    return fetch(ASSET_URL + path)
  }
}


/**
 * @param {Request} req
 * @param {string} pathname
 */
function httpHandler(req, pathname) {
  const reqHdrRaw = req.headers
  if (reqHdrRaw.has(&amp;#39;x-jsproxy&amp;#39;)) {
    return Response.error()
  }

  // preflight
  if (req.method === &amp;#39;OPTIONS&amp;#39; &amp;amp;&amp;amp;
      reqHdrRaw.has(&amp;#39;access-control-request-headers&amp;#39;)
  ) {
    return new Response(null, PREFLIGHT_INIT)
  }

  let acehOld = false
  let rawSvr = &amp;#39;&amp;#39;
  let rawLen = &amp;#39;&amp;#39;
  let rawEtag = &amp;#39;&amp;#39;

  const reqHdrNew = new Headers(reqHdrRaw)
  reqHdrNew.set(&amp;#39;x-jsproxy&amp;#39;, &amp;#39;1&amp;#39;)

  // 此处逻辑和 http-dec-req-hdr.lua 大致相同
  // https://github.com/EtherDream/jsproxy/blob/master/lua/http-dec-req-hdr.lua
  const refer = reqHdrNew.get(&amp;#39;referer&amp;#39;)
  const query = refer.substr(refer.indexOf(&amp;#39;?&amp;#39;) + 1)
  if (!query) {
    return makeRes(&amp;#39;missing params&amp;#39;, 403)
  }
  const param = new URLSearchParams(query)

  for (const [k, v] of Object.entries(param)) {
    if (k.substr(0, 2) === &amp;#39;--&amp;#39;) {
      // 系统信息
      switch (k.substr(2)) {
      case &amp;#39;aceh&amp;#39;:
        acehOld = true
        break
      case &amp;#39;raw-info&amp;#39;:
        [rawSvr, rawLen, rawEtag] = v.split(&amp;#39;|&amp;#39;)
        break
      }
    } else {
      // 还原 HTTP 请求头
      if (v) {
        reqHdrNew.set(k, v)
      } else {
        reqHdrNew.delete(k)
      }
    }
  }
  if (!param.has(&amp;#39;referer&amp;#39;)) {
    reqHdrNew.delete(&amp;#39;referer&amp;#39;)
  }

  // cfworker 会把路径中的 `//` 合并成 `/`
  const urlStr = pathname.replace(/^(https?):\/+/, &amp;#39;$1://&amp;#39;)
  const urlObj = newUrl(urlStr)
  if (!urlObj) {
    return makeRes(&amp;#39;invalid proxy url: &amp;#39; + urlStr, 403)
  }

  /** @type {RequestInit} */
  const reqInit = {
    method: req.method,
    headers: reqHdrNew,
    redirect: &amp;#39;manual&amp;#39;,
  }
  if (req.method === &amp;#39;POST&amp;#39;) {
    reqInit.body = req.body
  }
  return proxy(urlObj, reqInit, acehOld, rawLen, 0)
}


/**
 * 
 * @param {URL} urlObj 
 * @param {RequestInit} reqInit 
 * @param {number} retryTimes 
 */
async function proxy(urlObj, reqInit, acehOld, rawLen, retryTimes) {
  const res = await fetch(urlObj.href, reqInit)
  const resHdrOld = res.headers
  const resHdrNew = new Headers(resHdrOld)

  let expose = &amp;#39;*&amp;#39;
  
  for (const [k, v] of resHdrOld.entries()) {
    if (k === &amp;#39;access-control-allow-origin&amp;#39; ||
        k === &amp;#39;access-control-expose-headers&amp;#39; ||
        k === &amp;#39;location&amp;#39; ||
        k === &amp;#39;set-cookie&amp;#39;
    ) {
      const x = &amp;#39;--&amp;#39; + k
      resHdrNew.set(x, v)
      if (acehOld) {
        expose = expose + &amp;#39;,&amp;#39; + x
      }
      resHdrNew.delete(k)
    }
    else if (acehOld &amp;amp;&amp;amp;
      k !== &amp;#39;cache-control&amp;#39; &amp;amp;&amp;amp;
      k !== &amp;#39;content-language&amp;#39; &amp;amp;&amp;amp;
      k !== &amp;#39;content-type&amp;#39; &amp;amp;&amp;amp;
      k !== &amp;#39;expires&amp;#39; &amp;amp;&amp;amp;
      k !== &amp;#39;last-modified&amp;#39; &amp;amp;&amp;amp;
      k !== &amp;#39;pragma&amp;#39;
    ) {
      expose = expose + &amp;#39;,&amp;#39; + k
    }
  }

  if (acehOld) {
    expose = expose + &amp;#39;,--s&amp;#39;
    resHdrNew.set(&amp;#39;--t&amp;#39;, &amp;#39;1&amp;#39;)
  }

  // verify
  if (rawLen) {
    const newLen = resHdrOld.get(&amp;#39;content-length&amp;#39;) || &amp;#39;&amp;#39;
    const badLen = (rawLen !== newLen)

    if (badLen) {
      if (retryTimes &amp;lt; MAX_RETRY) {
        urlObj = await parseYtVideoRedir(urlObj, newLen, res)
        if (urlObj) {
          return proxy(urlObj, reqInit, acehOld, rawLen, retryTimes + 1)
        }
      }
      return makeRes(res.body, 400, {
        &amp;#39;--error&amp;#39;: `bad len: ${newLen}, except: ${rawLen}`,
        &amp;#39;access-control-expose-headers&amp;#39;: &amp;#39;--error&amp;#39;,
      })
    }

    if (retryTimes &amp;gt; 1) {
      resHdrNew.set(&amp;#39;--retry&amp;#39;, retryTimes)
    }
  }

  let status = res.status

  resHdrNew.set(&amp;#39;access-control-expose-headers&amp;#39;, expose)
  resHdrNew.set(&amp;#39;access-control-allow-origin&amp;#39;, &amp;#39;*&amp;#39;)
  resHdrNew.set(&amp;#39;--s&amp;#39;, status)
  resHdrNew.set(&amp;#39;--ver&amp;#39;, JS_VER)

  resHdrNew.delete(&amp;#39;content-security-policy&amp;#39;)
  resHdrNew.delete(&amp;#39;content-security-policy-report-only&amp;#39;)
  resHdrNew.delete(&amp;#39;clear-site-data&amp;#39;)

  if (status === 301 ||
      status === 302 ||
      status === 303 ||
      status === 307 ||
      status === 308
  ) {
    status = status + 10
  }

  return new Response(res.body, {
    status,
    headers: resHdrNew,
  })
}


/**
 * @param {URL} urlObj 
 */
function isYtUrl(urlObj) {
  return (
    urlObj.host.endsWith(&amp;#39;.googlevideo.com&amp;#39;) &amp;amp;&amp;amp;
    urlObj.pathname.startsWith(&amp;#39;/videoplayback&amp;#39;)
  )
}

/**
 * @param {URL} urlObj 
 * @param {number} newLen 
 * @param {Response} res 
 */
async function parseYtVideoRedir(urlObj, newLen, res) {
  if (newLen &amp;gt; 2000) {
    return null
  }
  if (!isYtUrl(urlObj)) {
    return null
  }
  try {
    const data = await res.text()
    urlObj = new URL(data)
  } catch (err) {
    return null
  }
  if (!isYtUrl(urlObj)) {
    return null
  }
  return urlObj
}
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
  </channel>
</rss>
